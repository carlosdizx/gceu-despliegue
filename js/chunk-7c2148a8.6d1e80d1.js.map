{"version":3,"sources":["webpack:///../../../src/mixins/transitionable/index.ts","webpack:///../../../src/components/VAlert/VAlert.ts","webpack:///../../../src/components/VAutocomplete/VAutocomplete.ts","webpack:///../../../src/components/VCombobox/VCombobox.ts"],"names":["name","props","mode","origin","transition","String","mixins","border","type","validator","closeLabel","default","coloredBorder","dense","dismissible","closeIcon","icon","Boolean","val","outlined","prominent","text","value","computed","__cachedBorder","this","data","staticClass","class","setBackgroundColor","$createElement","__cachedDismissible","color","VBtn","small","attrs","$vuetify","lang","t","on","click","VIcon","__cachedIcon","iconColor","classes","VSheet","computedColor","computedIcon","includes","hasColoredIcon","hasText","isDark","created","$attrs","hasOwnProperty","methods","genWrapper","children","$slots","prepend","$scopedSlots","close","toggle","genContent","genAlert","role","style","directives","isActive","setColor","render","h","defaultMenuProps","offsetY","offsetOverflow","VSelect","allowOverflow","autoSelectFirst","filter","itemText","queryText","hideNoData","menuProps","noFilter","searchInput","lazySearch","selectedIndex","computedItems","selectedValues","selectedItems","map","item","hasDisplayedItems","hideSelected","filteredItems","some","length","currentRange","selectedItem","getText","internalSearch","allItems","get","set","isAnyValueAllowed","isDirty","searchIsDirty","isSearching","multiple","menuCanShow","$_menuProps","find","i","listData","items","watch","internalValue","isFocused","document","$refs","input","isMenuActive","oldVal","activateMenu","destroyed","onFilteredItemsChanged","onInternalSearchChanged","updateMenuDimensions","menu","changeSelectedIndex","keyCode","deleteCurrentItem","curIndex","curItem","getDisabled","lastIndex","nextIndex","nextItem","clearableCallback","genInput","VTextField","mergeData","autocomplete","domProps","genInputSlot","slot","genSelections","hasSlot","onClick","isAppendInner","e","onInput","target","onKeyDown","onSpaceDown","onTabDown","onUpDown","selectItem","setSelectedItems","setSearch","updateSelf","valueComparator","getValue","hasItem","indexOf","onCopy","currentItem","currentItemText","event","delimiters","returnObject","editingIndex","computedCounterValue","delimiter","d","genChipSelection","chip","dblclick","onChipInput","onEnterDown","getMenuIndex","selectionStart","toLocaleLowerCase","setValue","updateEditing","index","findIndex","Object","updateCombobox","isUsingSlot","updateTags","menuIndex","itemToSelect","onPaste","pastedItemText","findExistingIndex"],"mappings":"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","file":"js/chunk-7c2148a8.6d1e80d1.js","sourcesContent":["import Vue from 'vue'\n\nexport default Vue.extend({\n  name: 'transitionable',\n\n  props: {\n    mode: String,\n    origin: String,\n    transition: String,\n  },\n})\n","// Styles\nimport './VAlert.sass'\n\n// Extensions\nimport VSheet from '../VSheet'\n\n// Components\nimport VBtn from '../VBtn'\nimport VIcon from '../VIcon'\n\n// Mixins\nimport Toggleable from '../../mixins/toggleable'\nimport Themeable from '../../mixins/themeable'\nimport Transitionable from '../../mixins/transitionable'\n\n// Utilities\nimport mixins from '../../util/mixins'\nimport { breaking } from '../../util/console'\n\n// Types\nimport { VNodeData } from 'vue'\nimport { VNode } from 'vue/types'\n\n/* @vue/component */\nexport default mixins(\n  VSheet,\n  Toggleable,\n  Transitionable\n).extend({\n  name: 'v-alert',\n\n  props: {\n    border: {\n      type: String,\n      validator (val: string) {\n        return [\n          'top',\n          'right',\n          'bottom',\n          'left',\n        ].includes(val)\n      },\n    },\n    closeLabel: {\n      type: String,\n      default: '$vuetify.close',\n    },\n    coloredBorder: Boolean,\n    dense: Boolean,\n    dismissible: Boolean,\n    closeIcon: {\n      type: String,\n      default: '$cancel',\n    },\n    icon: {\n      default: '',\n      type: [Boolean, String],\n      validator (val: boolean | string) {\n        return typeof val === 'string' || val === false\n      },\n    },\n    outlined: Boolean,\n    prominent: Boolean,\n    text: Boolean,\n    type: {\n      type: String,\n      validator (val: string) {\n        return [\n          'info',\n          'error',\n          'success',\n          'warning',\n        ].includes(val)\n      },\n    },\n    value: {\n      type: Boolean,\n      default: true,\n    },\n  },\n\n  computed: {\n    __cachedBorder (): VNode | null {\n      if (!this.border) return null\n\n      let data: VNodeData = {\n        staticClass: 'v-alert__border',\n        class: {\n          [`v-alert__border--${this.border}`]: true,\n        },\n      }\n\n      if (this.coloredBorder) {\n        data = this.setBackgroundColor(this.computedColor, data)\n        data.class['v-alert__border--has-color'] = true\n      }\n\n      return this.$createElement('div', data)\n    },\n    __cachedDismissible (): VNode | null {\n      if (!this.dismissible) return null\n\n      const color = this.iconColor\n\n      return this.$createElement(VBtn, {\n        staticClass: 'v-alert__dismissible',\n        props: {\n          color,\n          icon: true,\n          small: true,\n        },\n        attrs: {\n          'aria-label': this.$vuetify.lang.t(this.closeLabel),\n        },\n        on: {\n          click: () => (this.isActive = false),\n        },\n      }, [\n        this.$createElement(VIcon, {\n          props: { color },\n        }, this.closeIcon),\n      ])\n    },\n    __cachedIcon (): VNode | null {\n      if (!this.computedIcon) return null\n\n      return this.$createElement(VIcon, {\n        staticClass: 'v-alert__icon',\n        props: { color: this.iconColor },\n      }, this.computedIcon)\n    },\n    classes (): object {\n      const classes: Record<string, boolean> = {\n        ...VSheet.options.computed.classes.call(this),\n        'v-alert--border': Boolean(this.border),\n        'v-alert--dense': this.dense,\n        'v-alert--outlined': this.outlined,\n        'v-alert--prominent': this.prominent,\n        'v-alert--text': this.text,\n      }\n\n      if (this.border) {\n        classes[`v-alert--border-${this.border}`] = true\n      }\n\n      return classes\n    },\n    computedColor (): string {\n      return this.color || this.type\n    },\n    computedIcon (): string | boolean {\n      if (this.icon === false) return false\n      if (typeof this.icon === 'string' && this.icon) return this.icon\n      if (!['error', 'info', 'success', 'warning'].includes(this.type)) return false\n\n      return `$${this.type}`\n    },\n    hasColoredIcon (): boolean {\n      return (\n        this.hasText ||\n        (Boolean(this.border) && this.coloredBorder)\n      )\n    },\n    hasText (): boolean {\n      return this.text || this.outlined\n    },\n    iconColor (): string | undefined {\n      return this.hasColoredIcon ? this.computedColor : undefined\n    },\n    isDark (): boolean {\n      if (\n        this.type &&\n        !this.coloredBorder &&\n        !this.outlined\n      ) return true\n\n      return Themeable.options.computed.isDark.call(this)\n    },\n  },\n\n  created () {\n    /* istanbul ignore next */\n    if (this.$attrs.hasOwnProperty('outline')) {\n      breaking('outline', 'outlined', this)\n    }\n  },\n\n  methods: {\n    genWrapper (): VNode {\n      const children = [\n        this.$slots.prepend || this.__cachedIcon,\n        this.genContent(),\n        this.__cachedBorder,\n        this.$slots.append,\n        this.$scopedSlots.close\n          ? this.$scopedSlots.close({ toggle: this.toggle })\n          : this.__cachedDismissible,\n      ]\n\n      const data: VNodeData = {\n        staticClass: 'v-alert__wrapper',\n      }\n\n      return this.$createElement('div', data, children)\n    },\n    genContent (): VNode {\n      return this.$createElement('div', {\n        staticClass: 'v-alert__content',\n      }, this.$slots.default)\n    },\n    genAlert (): VNode {\n      let data: VNodeData = {\n        staticClass: 'v-alert',\n        attrs: {\n          role: 'alert',\n        },\n        on: this.listeners$,\n        class: this.classes,\n        style: this.styles,\n        directives: [{\n          name: 'show',\n          value: this.isActive,\n        }],\n      }\n\n      if (!this.coloredBorder) {\n        const setColor = this.hasText ? this.setTextColor : this.setBackgroundColor\n        data = setColor(this.computedColor, data)\n      }\n\n      return this.$createElement('div', data, [this.genWrapper()])\n    },\n    /** @public */\n    toggle () {\n      this.isActive = !this.isActive\n    },\n  },\n\n  render (h): VNode {\n    const render = this.genAlert()\n\n    if (!this.transition) return render\n\n    return h('transition', {\n      props: {\n        name: this.transition,\n        origin: this.origin,\n        mode: this.mode,\n      },\n    }, [render])\n  },\n})\n","// Styles\nimport './VAutocomplete.sass'\n\n// Extensions\nimport VSelect, { defaultMenuProps as VSelectMenuProps } from '../VSelect/VSelect'\nimport VTextField from '../VTextField/VTextField'\n\n// Utilities\nimport mergeData from '../../util/mergeData'\nimport {\n  getObjectValueByPath,\n  getPropertyFromItem,\n  keyCodes,\n} from '../../util/helpers'\n\n// Types\nimport { PropType, VNode } from 'vue'\nimport { PropValidator } from 'vue/types/options'\n\nconst defaultMenuProps = {\n  ...VSelectMenuProps,\n  offsetY: true,\n  offsetOverflow: true,\n  transition: false,\n}\n\n/* @vue/component */\nexport default VSelect.extend({\n  name: 'v-autocomplete',\n\n  props: {\n    allowOverflow: {\n      type: Boolean,\n      default: true,\n    },\n    autoSelectFirst: {\n      type: Boolean,\n      default: false,\n    },\n    filter: {\n      type: Function,\n      default: (item: any, queryText: string, itemText: string) => {\n        return itemText.toLocaleLowerCase().indexOf(queryText.toLocaleLowerCase()) > -1\n      },\n    } as PropValidator<(item: any, queryText: string, itemText: string) => boolean>,\n    hideNoData: Boolean,\n    menuProps: {\n      type: VSelect.options.props.menuProps.type,\n      default: () => defaultMenuProps,\n    },\n    noFilter: Boolean,\n    searchInput: {\n      type: String as PropType<string | null>,\n    },\n  },\n\n  data () {\n    return {\n      lazySearch: this.searchInput,\n    }\n  },\n\n  computed: {\n    classes (): object {\n      return {\n        ...VSelect.options.computed.classes.call(this),\n        'v-autocomplete': true,\n        'v-autocomplete--is-selecting-index': this.selectedIndex > -1,\n      }\n    },\n    computedItems (): object[] {\n      return this.filteredItems\n    },\n    selectedValues (): object[] {\n      return this.selectedItems.map(item => this.getValue(item))\n    },\n    hasDisplayedItems (): boolean {\n      return this.hideSelected\n        ? this.filteredItems.some(item => !this.hasItem(item))\n        : this.filteredItems.length > 0\n    },\n    currentRange (): number {\n      if (this.selectedItem == null) return 0\n\n      return String(this.getText(this.selectedItem)).length\n    },\n    filteredItems (): object[] {\n      if (!this.isSearching || this.noFilter || this.internalSearch == null) return this.allItems\n\n      return this.allItems.filter(item => {\n        const value = getPropertyFromItem(item, this.itemText)\n        const text = value != null ? String(value) : ''\n\n        return this.filter(item, String(this.internalSearch), text)\n      })\n    },\n    internalSearch: {\n      get (): string | null {\n        return this.lazySearch\n      },\n      set (val: any) { // TODO: this should be `string | null` but it breaks lots of other types\n        // emit update event only when the new\n        // search value is different from previous\n        if (this.lazySearch !== val) {\n          this.lazySearch = val\n          this.$emit('update:search-input', val)\n        }\n      },\n    },\n    isAnyValueAllowed (): boolean {\n      return false\n    },\n    isDirty (): boolean {\n      return this.searchIsDirty || this.selectedItems.length > 0\n    },\n    isSearching (): boolean {\n      return (\n        this.multiple &&\n        this.searchIsDirty\n      ) || (\n        this.searchIsDirty &&\n        this.internalSearch !== this.getText(this.selectedItem)\n      )\n    },\n    menuCanShow (): boolean {\n      if (!this.isFocused) return false\n\n      return this.hasDisplayedItems || !this.hideNoData\n    },\n    $_menuProps (): object {\n      const props = VSelect.options.computed.$_menuProps.call(this);\n      (props as any).contentClass = `v-autocomplete__content ${(props as any).contentClass || ''}`.trim()\n      return {\n        ...defaultMenuProps,\n        ...props,\n      }\n    },\n    searchIsDirty (): boolean {\n      return this.internalSearch != null &&\n        this.internalSearch !== ''\n    },\n    selectedItem (): any {\n      if (this.multiple) return null\n\n      return this.selectedItems.find(i => {\n        return this.valueComparator(this.getValue(i), this.getValue(this.internalValue))\n      })\n    },\n    listData () {\n      const data = VSelect.options.computed.listData.call(this) as any\n\n      data.props = {\n        ...data.props,\n        items: this.virtualizedItems,\n        noFilter: (\n          this.noFilter ||\n          !this.isSearching ||\n          !this.filteredItems.length\n        ),\n        searchInput: this.internalSearch,\n      }\n\n      return data\n    },\n  },\n\n  watch: {\n    filteredItems: 'onFilteredItemsChanged',\n    internalValue: 'setSearch',\n    isFocused (val) {\n      if (val) {\n        document.addEventListener('copy', this.onCopy)\n        this.$refs.input && this.$refs.input.select()\n      } else {\n        document.removeEventListener('copy', this.onCopy)\n        this.$refs.input && this.$refs.input.blur()\n        this.updateSelf()\n      }\n    },\n    isMenuActive (val) {\n      if (val || !this.hasSlot) return\n\n      this.lazySearch = null\n    },\n    items (val, oldVal) {\n      // If we are focused, the menu\n      // is not active, hide no data is enabled,\n      // and items change\n      // User is probably async loading\n      // items, try to activate the menu\n      if (\n        !(oldVal && oldVal.length) &&\n        this.hideNoData &&\n        this.isFocused &&\n        !this.isMenuActive &&\n        val.length\n      ) this.activateMenu()\n    },\n    searchInput (val: string) {\n      this.lazySearch = val\n    },\n    internalSearch: 'onInternalSearchChanged',\n    itemText: 'updateSelf',\n  },\n\n  created () {\n    this.setSearch()\n  },\n\n  destroyed () {\n    document.removeEventListener('copy', this.onCopy)\n  },\n\n  methods: {\n    onFilteredItemsChanged (val: never[], oldVal: never[]) {\n      // TODO: How is the watcher triggered\n      // for duplicate items? no idea\n      if (val === oldVal) return\n\n      this.setMenuIndex(-1)\n\n      this.$nextTick(() => {\n        if (\n          !this.internalSearch ||\n          (val.length !== 1 &&\n            !this.autoSelectFirst)\n        ) return\n\n        this.$refs.menu.getTiles()\n        this.setMenuIndex(0)\n      })\n    },\n    onInternalSearchChanged () {\n      this.updateMenuDimensions()\n    },\n    updateMenuDimensions () {\n      // Type from menuable is not making it through\n      this.isMenuActive && this.$refs.menu && this.$refs.menu.updateDimensions()\n    },\n    changeSelectedIndex (keyCode: number) {\n      // Do not allow changing of selectedIndex\n      // when search is dirty\n      if (this.searchIsDirty) return\n\n      if (this.multiple && keyCode === keyCodes.left) {\n        if (this.selectedIndex === -1) {\n          this.selectedIndex = this.selectedItems.length - 1\n        } else {\n          this.selectedIndex--\n        }\n      } else if (this.multiple && keyCode === keyCodes.right) {\n        if (this.selectedIndex >= this.selectedItems.length - 1) {\n          this.selectedIndex = -1\n        } else {\n          this.selectedIndex++\n        }\n      } else if (keyCode === keyCodes.backspace || keyCode === keyCodes.delete) {\n        this.deleteCurrentItem()\n      }\n    },\n    deleteCurrentItem () {\n      const curIndex = this.selectedIndex\n      const curItem = this.selectedItems[curIndex]\n\n      // Do nothing if input or item is disabled\n      if (\n        !this.isInteractive ||\n        this.getDisabled(curItem)\n      ) return\n\n      const lastIndex = this.selectedItems.length - 1\n\n      // Select the last item if\n      // there is no selection\n      if (\n        this.selectedIndex === -1 &&\n        lastIndex !== 0\n      ) {\n        this.selectedIndex = lastIndex\n\n        return\n      }\n\n      const length = this.selectedItems.length\n      const nextIndex = curIndex !== length - 1\n        ? curIndex\n        : curIndex - 1\n      const nextItem = this.selectedItems[nextIndex]\n\n      if (!nextItem) {\n        this.setValue(this.multiple ? [] : null)\n      } else {\n        this.selectItem(curItem)\n      }\n\n      this.selectedIndex = nextIndex\n    },\n    clearableCallback () {\n      this.internalSearch = null\n\n      VSelect.options.methods.clearableCallback.call(this)\n    },\n    genInput () {\n      const input = VTextField.options.methods.genInput.call(this)\n\n      input.data = mergeData(input.data!, {\n        attrs: {\n          'aria-activedescendant': getObjectValueByPath(this.$refs.menu, 'activeTile.id'),\n          autocomplete: getObjectValueByPath(input.data!, 'attrs.autocomplete', 'off'),\n        },\n        domProps: { value: this.internalSearch },\n      })\n\n      return input\n    },\n    genInputSlot () {\n      const slot = VSelect.options.methods.genInputSlot.call(this)\n\n      slot.data!.attrs!.role = 'combobox'\n\n      return slot\n    },\n    genSelections (): VNode | never[] {\n      return this.hasSlot || this.multiple\n        ? VSelect.options.methods.genSelections.call(this)\n        : []\n    },\n    onClick (e: MouseEvent) {\n      if (!this.isInteractive) return\n\n      this.selectedIndex > -1\n        ? (this.selectedIndex = -1)\n        : this.onFocus()\n\n      if (!this.isAppendInner(e.target)) this.activateMenu()\n    },\n    onInput (e: Event) {\n      if (\n        this.selectedIndex > -1 ||\n        !e.target\n      ) return\n\n      const target = e.target as HTMLInputElement\n      const value = target.value\n\n      // If typing and menu is not currently active\n      if (target.value) this.activateMenu()\n\n      this.internalSearch = value\n      this.badInput = target.validity && target.validity.badInput\n    },\n    onKeyDown (e: KeyboardEvent) {\n      const keyCode = e.keyCode\n\n      if (\n        e.ctrlKey ||\n        ![keyCodes.home, keyCodes.end].includes(keyCode)\n      ) {\n        VSelect.options.methods.onKeyDown.call(this, e)\n      }\n\n      // The ordering is important here\n      // allows new value to be updated\n      // and then moves the index to the\n      // proper location\n      this.changeSelectedIndex(keyCode)\n    },\n    onSpaceDown (e: KeyboardEvent) { /* noop */ },\n    onTabDown (e: KeyboardEvent) {\n      VSelect.options.methods.onTabDown.call(this, e)\n      this.updateSelf()\n    },\n    onUpDown (e: Event) {\n      // Prevent screen from scrolling\n      e.preventDefault()\n\n      // For autocomplete / combobox, cycling\n      // interfers with native up/down behavior\n      // instead activate the menu\n      this.activateMenu()\n    },\n    selectItem (item: object) {\n      VSelect.options.methods.selectItem.call(this, item)\n      this.setSearch()\n    },\n    setSelectedItems () {\n      VSelect.options.methods.setSelectedItems.call(this)\n\n      // #4273 Don't replace if searching\n      // #4403 Don't replace if focused\n      if (!this.isFocused) this.setSearch()\n    },\n    setSearch () {\n      // Wait for nextTick so selectedItem\n      // has had time to update\n      this.$nextTick(() => {\n        if (\n          !this.multiple ||\n          !this.internalSearch ||\n          !this.isMenuActive\n        ) {\n          this.internalSearch = (\n            !this.selectedItems.length ||\n            this.multiple ||\n            this.hasSlot\n          )\n            ? null\n            : this.getText(this.selectedItem)\n        }\n      })\n    },\n    updateSelf () {\n      if (\n        !this.searchIsDirty &&\n        !this.internalValue\n      ) return\n\n      if (\n        !this.multiple &&\n        !this.valueComparator(\n          this.internalSearch,\n          this.getValue(this.internalValue)\n        )\n      ) {\n        this.setSearch()\n      }\n    },\n    hasItem (item: any): boolean {\n      return this.selectedValues.indexOf(this.getValue(item)) > -1\n    },\n    onCopy (event: ClipboardEvent) {\n      if (this.selectedIndex === -1) return\n\n      const currentItem = this.selectedItems[this.selectedIndex]\n      const currentItemText = this.getText(currentItem)\n      event.clipboardData?.setData('text/plain', currentItemText)\n      event.clipboardData?.setData('text/vnd.vuetify.autocomplete.item+plain', currentItemText)\n      event.preventDefault()\n    },\n  },\n})\n","// Styles\nimport '../VAutocomplete/VAutocomplete.sass'\n\n// Extensions\nimport VSelect from '../VSelect/VSelect'\nimport VAutocomplete from '../VAutocomplete/VAutocomplete'\n\n// Utils\nimport { keyCodes } from '../../util/helpers'\n\n// Types\nimport { PropValidator } from 'vue/types/options'\n\n/* @vue/component */\nexport default VAutocomplete.extend({\n  name: 'v-combobox',\n\n  props: {\n    delimiters: {\n      type: Array,\n      default: () => ([]),\n    } as PropValidator<string[]>,\n    returnObject: {\n      type: Boolean,\n      default: true,\n    },\n  },\n\n  data: () => ({\n    editingIndex: -1,\n  }),\n\n  computed: {\n    computedCounterValue (): number {\n      return this.multiple\n        ? this.selectedItems.length\n        : (this.internalSearch || '').toString().length\n    },\n    hasSlot (): boolean {\n      return VSelect.options.computed.hasSlot.call(this) || this.multiple\n    },\n    isAnyValueAllowed (): boolean {\n      return true\n    },\n    menuCanShow (): boolean {\n      if (!this.isFocused) return false\n\n      return this.hasDisplayedItems ||\n        (!!this.$slots['no-data'] && !this.hideNoData)\n    },\n    searchIsDirty (): boolean {\n      return this.internalSearch != null\n    },\n  },\n\n  methods: {\n    onInternalSearchChanged (val: any) {\n      if (\n        val &&\n        this.multiple &&\n        this.delimiters.length\n      ) {\n        const delimiter = this.delimiters.find(d => val.endsWith(d))\n        if (delimiter != null) {\n          this.internalSearch = val.slice(0, val.length - delimiter.length)\n          this.updateTags()\n        }\n      }\n\n      this.updateMenuDimensions()\n    },\n    genInput () {\n      const input = VAutocomplete.options.methods.genInput.call(this)\n\n      delete input.data!.attrs!.name\n      input.data!.on!.paste = this.onPaste\n\n      return input\n    },\n    genChipSelection (item: object, index: number) {\n      const chip = VSelect.options.methods.genChipSelection.call(this, item, index)\n\n      // Allow user to update an existing value\n      if (this.multiple) {\n        chip.componentOptions!.listeners! = {\n          ...chip.componentOptions!.listeners!,\n          dblclick: () => {\n            this.editingIndex = index\n            this.internalSearch = this.getText(item)\n            this.selectedIndex = -1\n          },\n        }\n      }\n\n      return chip\n    },\n    onChipInput (item: object) {\n      VSelect.options.methods.onChipInput.call(this, item)\n\n      this.editingIndex = -1\n    },\n    // Requires a manual definition\n    // to overwrite removal in v-autocomplete\n    onEnterDown (e: Event) {\n      e.preventDefault()\n      // If has menu index, let v-select-list handle\n      if (this.getMenuIndex() > -1) return\n\n      this.$nextTick(this.updateSelf)\n    },\n    onFilteredItemsChanged (val: never[], oldVal: never[]) {\n      if (!this.autoSelectFirst) return\n\n      VAutocomplete.options.methods.onFilteredItemsChanged.call(this, val, oldVal)\n    },\n    onKeyDown (e: KeyboardEvent) {\n      const keyCode = e.keyCode\n\n      if (\n        e.ctrlKey ||\n        ![keyCodes.home, keyCodes.end].includes(keyCode)\n      ) {\n        VSelect.options.methods.onKeyDown.call(this, e)\n      }\n\n      // If user is at selection index of 0\n      // create a new tag\n      if (this.multiple &&\n        keyCode === keyCodes.left &&\n        this.$refs.input.selectionStart === 0\n      ) {\n        this.updateSelf()\n      } else if (keyCode === keyCodes.enter) {\n        this.onEnterDown(e)\n      }\n\n      // The ordering is important here\n      // allows new value to be updated\n      // and then moves the index to the\n      // proper location\n      this.changeSelectedIndex(keyCode)\n    },\n    onTabDown (e: KeyboardEvent) {\n      // When adding tags, if searching and\n      // there is not a filtered options,\n      // add the value to the tags list\n      if (this.multiple &&\n        this.internalSearch &&\n        this.getMenuIndex() === -1\n      ) {\n        e.preventDefault()\n        e.stopPropagation()\n\n        return this.updateTags()\n      }\n\n      VAutocomplete.options.methods.onTabDown.call(this, e)\n    },\n    selectItem (item: object) {\n      // Currently only supports items:<string[]>\n      if (this.editingIndex > -1) {\n        this.updateEditing()\n      } else {\n        VAutocomplete.options.methods.selectItem.call(this, item)\n\n        // if selected item contains search value,\n        // remove the search string\n        if (\n          this.internalSearch &&\n          this.multiple &&\n          this.getText(item).toLocaleLowerCase().includes(this.internalSearch.toLocaleLowerCase())\n        ) {\n          this.internalSearch = null\n        }\n      }\n    },\n    setSelectedItems () {\n      if (this.internalValue == null ||\n        this.internalValue === ''\n      ) {\n        this.selectedItems = []\n      } else {\n        this.selectedItems = this.multiple ? this.internalValue : [this.internalValue]\n      }\n    },\n    setValue (value?: any) {\n      VSelect.options.methods.setValue.call(this, value ?? this.internalSearch)\n    },\n    updateEditing () {\n      const value = this.internalValue.slice()\n      const index = this.selectedItems.findIndex(item =>\n        this.getText(item) === this.internalSearch)\n\n      // If user enters a duplicate text on chip edit,\n      // don't add it, move it to the end of the list\n      if (index > -1) {\n        const item = typeof value[index] === 'object'\n          ? Object.assign({}, value[index])\n          : value[index]\n\n        value.splice(index, 1)\n        value.push(item)\n      } else {\n        value[this.editingIndex] = this.internalSearch\n      }\n\n      this.setValue(value)\n      this.editingIndex = -1\n      this.internalSearch = null\n    },\n    updateCombobox () {\n      // If search is not dirty, do nothing\n      if (!this.searchIsDirty) return\n\n      // The internal search is not matching\n      // the internal value, update the input\n      if (this.internalSearch !== this.getText(this.internalValue)) this.setValue()\n\n      // Reset search if using slot to avoid a double input\n      const isUsingSlot = Boolean(this.$scopedSlots.selection) || this.hasChips\n      if (isUsingSlot) this.internalSearch = null\n    },\n    updateSelf () {\n      this.multiple ? this.updateTags() : this.updateCombobox()\n    },\n    updateTags () {\n      const menuIndex = this.getMenuIndex()\n\n      // If the user is not searching\n      // and no menu item is selected\n      // or if the search is empty\n      // do nothing\n      if ((menuIndex < 0 && !this.searchIsDirty) ||\n          !this.internalSearch) return\n\n      if (this.editingIndex > -1) {\n        return this.updateEditing()\n      }\n\n      const index = this.selectedItems.findIndex(item =>\n        this.internalSearch === this.getText(item))\n\n      // If the duplicate item is an object,\n      // copy it, so that it can be added again later\n      const itemToSelect = index > -1 && typeof this.selectedItems[index] === 'object'\n        ? Object.assign({}, this.selectedItems[index])\n        : this.internalSearch\n\n      // If it already exists, do nothing\n      // this might need to change to bring\n      // the duplicated item to the last entered\n      if (index > -1) {\n        const internalValue = this.internalValue.slice()\n        internalValue.splice(index, 1)\n\n        this.setValue(internalValue)\n      }\n\n      // If menu index is greater than 1\n      // the selection is handled elsewhere\n      // TODO: find out where\n      if (menuIndex > -1) return (this.internalSearch = null)\n\n      this.selectItem(itemToSelect)\n\n      this.internalSearch = null\n    },\n    onPaste (event: ClipboardEvent) {\n      if (!this.multiple || this.searchIsDirty) return\n\n      const pastedItemText = event.clipboardData?.getData('text/vnd.vuetify.autocomplete.item+plain')\n      if (pastedItemText && this.findExistingIndex(pastedItemText as any) === -1) {\n        event.preventDefault()\n        VSelect.options.methods.selectItem.call(this, pastedItemText as any)\n      }\n    },\n    clearableCallback () {\n      this.editingIndex = -1\n\n      VAutocomplete.options.methods.clearableCallback.call(this)\n    },\n  },\n})\n"],"sourceRoot":""}